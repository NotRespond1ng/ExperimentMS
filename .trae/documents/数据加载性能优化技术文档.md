# 实验数据管理系统 - 数据加载性能优化技术文档

## 1. 当前系统数据加载问题分析

### 1.1 核心问题识别

#### 重复数据加载问题
- **问题描述**: 每个页面组件在 `onMounted` 时都会独立调用API获取数据
- **影响范围**: PersonManagement、SensorManagement、ExperimentManagement等所有模块页面
- **性能损耗**: 相同数据被重复请求多次，造成不必要的网络开销

#### 缺乏有效缓存机制
- **问题描述**: 即使 `dataStore` 中已有数据，各页面仍会重新请求相同的数据
- **根本原因**: 缺少数据状态跟踪和缓存有效性验证
- **用户体验**: 页面切换时出现重复的加载等待时间

#### 并发API请求过多
- **问题描述**: `initializeData()` 函数使用 `Promise.all` 同时发起6个API请求
- **具体请求**: 批次、人员、实验、竞品文件、指尖血数据、传感器
- **服务器压力**: 高并发请求可能导致服务器响应延迟

#### 网络配置不优化
- **超时设置**: 当前10秒超时可能不适合大数据量场景
- **缺乏重试**: 没有请求失败重试机制
- **无优先级**: 缺乏请求优先级管理

### 1.2 性能影响评估

| 问题类型 | 影响程度 | 用户感知 | 优化优先级 |
|---------|---------|---------|----------|
| 重复数据加载 | 高 | 页面切换慢 | P0 |
| 缺乏缓存机制 | 高 | 重复等待 | P0 |
| 并发请求过多 | 中 | 初始加载慢 | P1 |
| 网络配置 | 低 | 偶发超时 | P2 |

## 2. 智能缓存机制设计

### 2.1 数据状态管理

#### 缓存状态跟踪
```typescript
// stores/data.ts 增强版本
interface DataCacheState {
  loaded: boolean
  loading: boolean
  lastUpdated: number
  error: string | null
}

const cacheStates = ref<Record<string, DataCacheState>>({
  batches: { loaded: false, loading: false, lastUpdated: 0, error: null },
  persons: { loaded: false, loading: false, lastUpdated: 0, error: null },
  experiments: { loaded: false, loading: false, lastUpdated: 0, error: null },
  competitorFiles: { loaded: false, loading: false, lastUpdated: 0, error: null },
  fingerBloodData: { loaded: false, loading: false, lastUpdated: 0, error: null },
  sensors: { loaded: false, loading: false, lastUpdated: 0, error: null }
})
```

#### 缓存有效性策略
```typescript
// 缓存过期时间配置（毫秒）
const CACHE_EXPIRY = {
  batches: 5 * 60 * 1000,        // 5分钟
  persons: 3 * 60 * 1000,        // 3分钟
  experiments: 2 * 60 * 1000,    // 2分钟
  competitorFiles: 1 * 60 * 1000, // 1分钟
  fingerBloodData: 30 * 1000,    // 30秒
  sensors: 1 * 60 * 1000         // 1分钟
}

// 检查缓存是否有效
const isCacheValid = (dataType: string): boolean => {
  const state = cacheStates.value[dataType]
  if (!state.loaded) return false
  
  const now = Date.now()
  const expiry = CACHE_EXPIRY[dataType] || 60000
  return (now - state.lastUpdated) < expiry
}
```

### 2.2 智能数据获取

#### 条件加载逻辑
```typescript
const loadDataIfNeeded = async (dataType: string, forceRefresh = false) => {
  const state = cacheStates.value[dataType]
  
  // 如果正在加载，返回现有的Promise
  if (state.loading) {
    return await waitForLoading(dataType)
  }
  
  // 如果缓存有效且不强制刷新，直接返回
  if (!forceRefresh && isCacheValid(dataType)) {
    return
  }
  
  // 开始加载数据
  state.loading = true
  state.error = null
  
  try {
    const data = await ApiService[`get${capitalize(dataType)}`]()
    updateDataStore(dataType, data)
    state.loaded = true
    state.lastUpdated = Date.now()
  } catch (error) {
    state.error = error.message
    throw error
  } finally {
    state.loading = false
  }
}
```

### 2.3 内存缓存优化

#### LRU缓存实现
```typescript
class LRUCache<T> {
  private cache = new Map<string, T>()
  private maxSize: number
  
  constructor(maxSize = 100) {
    this.maxSize = maxSize
  }
  
  get(key: string): T | undefined {
    const value = this.cache.get(key)
    if (value !== undefined) {
      // 移到最后（最近使用）
      this.cache.delete(key)
      this.cache.set(key, value)
    }
    return value
  }
  
  set(key: string, value: T): void {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    } else if (this.cache.size >= this.maxSize) {
      // 删除最久未使用的项
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    this.cache.set(key, value)
  }
}

// 应用到数据存储
const queryCache = new LRUCache<any>(50)
```

## 3. 按需加载策略

### 3.1 模块化数据加载

#### 页面级数据依赖
```typescript
// 定义每个页面的数据依赖
const PAGE_DATA_DEPENDENCIES = {
  dashboard: ['batches', 'persons', 'experiments'], // 仅加载统计需要的数据
  batchManagement: ['batches'],
  personManagement: ['persons', 'batches'],
  experimentManagement: ['experiments', 'persons', 'batches'],
  competitorData: ['competitorFiles', 'persons', 'batches'],
  fingerBloodData: ['fingerBloodData', 'persons', 'batches'],
  sensorManagement: ['sensors', 'persons', 'batches']
}

// 按需加载函数
const loadPageData = async (pageName: string, forceRefresh = false) => {
  const dependencies = PAGE_DATA_DEPENDENCIES[pageName] || []
  const loadPromises = dependencies.map(dep => loadDataIfNeeded(dep, forceRefresh))
  await Promise.all(loadPromises)
}
```

#### 路由级数据预加载
```typescript
// router/index.ts 增强版本
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  const dataStore = useDataStore()
  
  // 权限检查
  if (!authStore.isLoggedIn && to.name !== 'Login') {
    return next({ name: 'Login' })
  }
  
  // 预加载页面数据
  if (to.meta?.pageName) {
    try {
      await dataStore.loadPageData(to.meta.pageName)
    } catch (error) {
      console.warn('预加载数据失败:', error)
    }
  }
  
  next()
})
```

### 3.2 懒加载实现

#### 组件级懒加载
```typescript
// composables/useLazyData.ts
export const useLazyData = <T>(dataType: string, immediate = true) => {
  const data = ref<T[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const load = async (forceRefresh = false) => {
    if (loading.value) return
    
    loading.value = true
    error.value = null
    
    try {
      await loadDataIfNeeded(dataType, forceRefresh)
      data.value = getDataFromStore(dataType)
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }
  
  if (immediate) {
    load()
  }
  
  return { data, loading, error, load, refresh: () => load(true) }
}
```

#### 分页数据懒加载
```typescript
// 大数据集分页加载
const useInfiniteScroll = (dataType: string, pageSize = 20) => {
  const items = ref([])
  const hasMore = ref(true)
  const loading = ref(false)
  
  const loadMore = async () => {
    if (loading.value || !hasMore.value) return
    
    loading.value = true
    try {
      const newItems = await ApiService.getPaginatedData(dataType, {
        offset: items.value.length,
        limit: pageSize
      })
      
      items.value.push(...newItems)
      hasMore.value = newItems.length === pageSize
    } finally {
      loading.value = false
    }
  }
  
  return { items, hasMore, loading, loadMore }
}
```

## 4. API请求优化方案

### 4.1 请求队列管理

#### 并发控制
```typescript
class RequestQueue {
  private queue: Array<() => Promise<any>> = []
  private running = 0
  private maxConcurrent = 3
  
  async add<T>(request: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await request()
          resolve(result)
        } catch (error) {
          reject(error)
        }
      })
      this.process()
    })
  }
  
  private async process() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return
    }
    
    this.running++
    const request = this.queue.shift()!
    
    try {
      await request()
    } finally {
      this.running--
      this.process()
    }
  }
}

const requestQueue = new RequestQueue()
```

#### 请求去重
```typescript
class RequestDeduplicator {
  private pendingRequests = new Map<string, Promise<any>>()
  
  async request<T>(key: string, requestFn: () => Promise<T>): Promise<T> {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key) as Promise<T>
    }
    
    const promise = requestFn().finally(() => {
      this.pendingRequests.delete(key)
    })
    
    this.pendingRequests.set(key, promise)
    return promise
  }
}

const deduplicator = new RequestDeduplicator()
```

### 4.2 网络优化配置

#### 自适应超时
```typescript
// services/api.ts 优化版本
const createOptimizedApi = () => {
  const api = axios.create({
    baseURL: 'http://localhost:8000',
    timeout: 15000, // 增加到15秒
    headers: {
      'Content-Type': 'application/json'
    }
  })
  
  // 请求拦截器 - 添加请求ID和优先级
  api.interceptors.request.use((config) => {
    config.metadata = {
      requestId: generateRequestId(),
      startTime: Date.now(),
      priority: config.priority || 'normal'
    }
    return config
  })
  
  // 响应拦截器 - 记录性能指标
  api.interceptors.response.use(
    (response) => {
      const duration = Date.now() - response.config.metadata.startTime
      console.log(`API请求 ${response.config.url} 耗时: ${duration}ms`)
      return response
    },
    (error) => {
      // 自动重试逻辑
      return handleRetry(error)
    }
  )
  
  return api
}
```

#### 智能重试机制
```typescript
const handleRetry = async (error: any) => {
  const config = error.config
  const maxRetries = 3
  const retryDelay = 1000
  
  if (!config.retryCount) {
    config.retryCount = 0
  }
  
  if (config.retryCount < maxRetries && isRetryableError(error)) {
    config.retryCount++
    
    // 指数退避
    const delay = retryDelay * Math.pow(2, config.retryCount - 1)
    await new Promise(resolve => setTimeout(resolve, delay))
    
    return api.request(config)
  }
  
  return Promise.reject(error)
}

const isRetryableError = (error: any): boolean => {
  return (
    error.code === 'ECONNABORTED' || // 超时
    error.response?.status >= 500 || // 服务器错误
    error.response?.status === 429    // 限流
  )
}
```

### 4.3 数据压缩和优化

#### 响应数据压缩
```typescript
// 启用gzip压缩
const api = axios.create({
  baseURL: 'http://localhost:8000',
  headers: {
    'Accept-Encoding': 'gzip, deflate, br'
  }
})
```

#### 字段选择和过滤
```typescript
// API增强 - 支持字段选择
class OptimizedApiService {
  static async getBatches(fields?: string[]) {
    const params = fields ? { fields: fields.join(',') } : {}
    const response = await api.get('/api/batches/', { params })
    return response.data
  }
  
  static async getPersons(options?: {
    fields?: string[]
    batchId?: number
    limit?: number
    offset?: number
  }) {
    const params = {
      ...(options?.fields && { fields: options.fields.join(',') }),
      ...(options?.batchId && { batch_id: options.batchId }),
      ...(options?.limit && { limit: options.limit }),
      ...(options?.offset && { offset: options.offset })
    }
    const response = await api.get('/api/persons/', { params })
    return response.data
  }
}
```

## 5. 用户体验改进措施

### 5.1 加载状态优化

#### 骨架屏实现
```vue
<!-- components/SkeletonLoader.vue -->
<template>
  <div class="skeleton-container">
    <div v-for="n in count" :key="n" class="skeleton-item">
      <div class="skeleton-avatar"></div>
      <div class="skeleton-content">
        <div class="skeleton-line skeleton-line-title"></div>
        <div class="skeleton-line skeleton-line-subtitle"></div>
        <div class="skeleton-line skeleton-line-text"></div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
defineProps<{
  count?: number
}>()
</script>

<style scoped>
.skeleton-item {
  display: flex;
  padding: 16px;
  border-bottom: 1px solid #f0f0f0;
}

.skeleton-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: skeleton-loading 1.5s infinite;
}

.skeleton-line {
  height: 16px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: skeleton-loading 1.5s infinite;
  margin-bottom: 8px;
}

.skeleton-line-title { width: 60%; }
.skeleton-line-subtitle { width: 40%; }
.skeleton-line-text { width: 80%; }

@keyframes skeleton-loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
</style>
```

#### 渐进式加载
```typescript
// composables/useProgressiveLoading.ts
export const useProgressiveLoading = (dataTypes: string[]) => {
  const loadingStates = ref<Record<string, boolean>>({})
  const loadedData = ref<Record<string, any>>({})
  const allLoaded = computed(() => 
    dataTypes.every(type => !loadingStates.value[type])
  )
  
  const loadProgressively = async () => {
    // 按优先级顺序加载
    const priorityOrder = ['batches', 'persons', 'experiments', 'sensors', 'competitorFiles', 'fingerBloodData']
    
    for (const dataType of priorityOrder) {
      if (dataTypes.includes(dataType)) {
        loadingStates.value[dataType] = true
        
        try {
          await loadDataIfNeeded(dataType)
          loadedData.value[dataType] = getDataFromStore(dataType)
        } catch (error) {
          console.error(`加载 ${dataType} 失败:`, error)
        } finally {
          loadingStates.value[dataType] = false
        }
        
        // 添加小延迟，让用户看到渐进加载效果
        await new Promise(resolve => setTimeout(resolve, 100))
      }
    }
  }
  
  return {
    loadingStates: readonly(loadingStates),
    loadedData: readonly(loadedData),
    allLoaded,
    loadProgressively
  }
}
```

### 5.2 错误处理和重试

#### 用户友好的错误提示
```typescript
// utils/errorHandler.ts
export const handleDataLoadError = (error: any, dataType: string) => {
  const errorMessages = {
    network: '网络连接异常，请检查网络设置',
    timeout: '请求超时，请稍后重试',
    server: '服务器暂时不可用，请稍后重试',
    permission: '没有权限访问该数据',
    default: '数据加载失败，请重试'
  }
  
  let messageType = 'default'
  
  if (error.code === 'ECONNABORTED') {
    messageType = 'timeout'
  } else if (error.response?.status === 403) {
    messageType = 'permission'
  } else if (error.response?.status >= 500) {
    messageType = 'server'
  } else if (!navigator.onLine) {
    messageType = 'network'
  }
  
  const message = errorMessages[messageType]
  
  ElMessage({
    type: 'error',
    message,
    duration: 5000,
    showClose: true
  })
  
  // 记录错误日志
  console.error(`数据加载错误 [${dataType}]:`, error)
}
```

#### 自动重试UI组件
```vue
<!-- components/RetryButton.vue -->
<template>
  <div class="retry-container">
    <el-result
      icon="warning"
      title="数据加载失败"
      :sub-title="errorMessage"
    >
      <template #extra>
        <el-button 
          type="primary" 
          :loading="retrying"
          @click="handleRetry"
        >
          {{ retrying ? '重试中...' : '重试' }}
        </el-button>
      </template>
    </el-result>
  </div>
</template>

<script setup lang="ts">
interface Props {
  errorMessage?: string
  onRetry: () => Promise<void>
}

const props = withDefaults(defineProps<Props>(), {
  errorMessage: '请求失败，请重试'
})

const retrying = ref(false)

const handleRetry = async () => {
  retrying.value = true
  try {
    await props.onRetry()
  } finally {
    retrying.value = false
  }
}
</script>
```

### 5.3 性能监控和分析

#### 性能指标收集
```typescript
// utils/performanceMonitor.ts
class PerformanceMonitor {
  private metrics: Array<{
    name: string
    duration: number
    timestamp: number
    success: boolean
  }> = []
  
  startTiming(name: string): () => void {
    const startTime = performance.now()
    
    return (success = true) => {
      const duration = performance.now() - startTime
      this.metrics.push({
        name,
        duration,
        timestamp: Date.now(),
        success
      })
      
      // 如果加载时间过长，发出警告
      if (duration > 3000) {
        console.warn(`性能警告: ${name} 加载时间过长 (${duration.toFixed(2)}ms)`)
      }
    }
  }
  
  getMetrics() {
    return this.metrics
  }
  
  getAverageLoadTime(name?: string) {
    const filtered = name 
      ? this.metrics.filter(m => m.name === name && m.success)
      : this.metrics.filter(m => m.success)
    
    if (filtered.length === 0) return 0
    
    const total = filtered.reduce((sum, m) => sum + m.duration, 0)
    return total / filtered.length
  }
}

export const performanceMonitor = new PerformanceMonitor()
```

## 6. 实施计划和优先级

### 6.1 实施阶段

#### 第一阶段（P0 - 立即实施）
1. **智能缓存机制**
   - 实现数据状态跟踪
   - 添加缓存有效性检查
   - 修改各页面组件的数据加载逻辑

2. **按需加载策略**
   - 定义页面数据依赖关系
   - 实现条件数据加载
   - 优化路由级数据预加载

#### 第二阶段（P1 - 短期优化）
1. **API请求优化**
   - 实现请求队列管理
   - 添加请求去重机制
   - 优化网络配置

2. **用户体验改进**
   - 添加骨架屏加载效果
   - 实现渐进式加载
   - 优化错误处理

#### 第三阶段（P2 - 长期优化）
1. **高级优化**
   - 实现数据压缩
   - 添加离线缓存
   - 性能监控和分析

### 6.2 预期效果

| 优化项目 | 预期改进 | 衡量指标 |
|---------|---------|----------|
| 智能缓存 | 减少70%重复请求 | API调用次数 |
| 按需加载 | 提升50%页面切换速度 | 页面加载时间 |
| 请求优化 | 减少30%网络延迟 | 平均响应时间 |
| 用户体验 | 提升80%感知性能 | 用户满意度 |

### 6.3 风险评估和缓解

#### 潜在风险
1. **缓存一致性**: 数据更新时缓存可能不同步
   - **缓解措施**: 实现智能缓存失效机制

2. **内存占用**: 缓存可能增加内存使用
   - **缓解措施**: 使用LRU缓存限制内存占用

3. **复杂性增加**: 优化可能增加代码复杂度
   - **缓解措施**: 充分的文档和测试覆盖

## 7. 总结

本优化方案通过智能缓存、按需加载、API优化和用户体验改进四个维度，全面解决了当前系统的数据加载性能问题。实施后预期将显著提升系统响应速度和用户体验，同时降低服务器负载和网络开销。

建议按照优先级分阶段实施，重点先解决重复数据加载和缓存机制问题，然后逐步完善其他优化措施。